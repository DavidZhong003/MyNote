# Java基础 #
## 一些关键字的使用 ##

## 多线程 ##

## 集合 ##
### 集合分类 ###
### arraylist源码 ###
### hashmap 源码 ###
## IO 流 ##

## 网络 ##
### 主机间通信方式 ###
1. 客户端-服务器（c/s） 客户端是请求方，服务器是提供方
2. 对等（p2p）   不区分客户和服务

### 计算机网络体系 ###

1. 七层协议

#### 运输层 ####

##### UDP和TCP的特点 #####
- UDP 面向报文（程序传下的报文不合并也不拆分，只添加UDP首部），无连接尽最大可能交付，没有拥塞控制
- TCP 面向连接，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块


1. UDP部首

![](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/bd6c05f3-02ee-4c8a-b374-40c87154a898.jpg)

2. TCP 部首

![](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/21a00b02-c0a6-4bcd-9af0-5ec6bb66e34c.jpg)

- **序号** 对字节流进行编码。例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** 期望收到下个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移** 首部的长度。
- **确认ACK** 当ACK=1时候，确认号有效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步SYN** 建立连接时的同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止FIN** 释放连接。 当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。

##### TCP3次握手和4次挥手 #####

![](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/086871db-5871-460f-97b7-126cd738bb0e.jpg)

A为客户端，B为服务器

1. B 监听状态，等待客户端连接
2. A 发送连接请求报文，syn =1 ，ack =0 ，序号为 x
3. B 收到后，同意连接，发送确认报文。syn=1 ，ack=1， 序号为 y ，确认号为x+1
4. A收到B的连接确认报文后，再向B发出确认，序号为x+1 ， 确认号为 y+1
5. B收到后，建立连接

![4次挥手](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/78f65456-666b-4044-b4ee-f7692dbbc0d3.jpg)

下面不讨论序号和确认号以及ack（ack建立连接后都为1）

1. A 发送连接释放报文段，FIN=1；
2. B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据；
3. 当 B 要不再需要连接时，发送连接释放请求报文段，FIN=1；
4. A 收到后发出确认，此时连接释放。

TIME_WAIT

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间。这么做有两个理由：

确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。
可能存在“已失效的连接请求报文段”，为了防止这种报文段出现在本次连接之外，需要等待一段时间。


#### 应用层 ####
----------

# Android 基础 #
## 4大组件 ##
（ANR 时间 activtiy 5s 广播10s 服务 20s）
### Activity ###
#### activity启动过程 ####
    从桌面启动一个程序，调用Activity的startActivity方法，内部调用startActivityForResult()方法。
    这个方法里面主要调用两个方法
	1，Instrumentation类中的execStartActivity（）
	里面主要逻辑，调用ActivityManagerProxy的startActivity()方法，通过Binder驱动调用ActivityManagerServices的startActivity
	方法。里面主要是获取intent中的信息封装，根据启动模式进行ActivityTask操作，然后调用applicationThread的scheduleLaunchActivity
	方法。里面通过handler发送消息给activityThread(LAUNCH_ACTIVITY)启动activity，handler接收到这消息后执行handleLaunchActivity
	方法。里面主要逻辑，在ActivityInfo中获取activity的相关信息，通过反射创建得到activity实例，然后执行activity的生命周期。
	2，获取启动结果后通过ActivityThread.sendActivityResult()，主要是applicationThread发送handler消息
	里面主要逻辑是，startActivity 成功后，判断当前的Activity是否是Resume状态，如果是调用Instrumentation.callActivityOnPause
	方法。	
#### 生命周期 ####
	onCreate(),onstart(),onResume(),onPause(),onStop(),onDestory()
	onRestart()[在onStop()-->onStart()-->onRestart()--onResume()]
		调用场景：从home桌面中回去；从其他activity back切换回来（本应用activity或者其他应用）
	onNewIntent()[-->onRestart()-->......]
		调用时机：该activity已经在任务栈中，当启动模式为SingleTop/SingleInstance时候，该activity再次启动（不是重新创建）执行
				
#### 启动模式 ####
	
- standard  普通模式，一直往ActivityStack中添加
- singleTop 检查当前ActivityStack顶是不是该activity，如果是不创建执行onNewIntent,否就创建
- singleTask检查当前ActivityStack内是否有该activity，如果有finish它上面的所有activtiy并且执行onNewIntent方法，否创建
- singleInstance 启动一个新的任务栈存放并创建activtiy

### Service ###
#### 两种模式及其生命周期 ####
- startService 模式
	onCreate()-->...(多次start onStartCommand()-->)...-->onDestory()
>onStartCommand() 4种返回值
	START_STICKY 粘性，如果服务的进程被kill，将保留start状态，下次创建就执行onStartCommand,但里面的intent是null，除非有新的start命令
	START_NOT_STICKY 非粘性，如果被kill，重启不创建
	START_REDELIVER_INTENT 重传Intent   如果执行玩onstartcommand 后服务被kill掉，系统会自动重启该服务并且传入intent值。
	START_STICKY_COMPATIBILITY  粘性的兼容版本，保证服务被kill后能够重启
- bindService 模式
	onCreate()-->onBind()-->onUnBind()--onDestory()

#### IntentService ####
	IntentService 是service的子类，可执行耗时任务。我们一般使用是实现其onHandlerIntent方法，在这个方法内我们可以执行耗时任务。
- 可执行耗时任务的原因
    内置一个线程handlerThread ，intentservice 在执行oncreate 方法时候会创建一个handlerThread线程和一个handler对象，而这个handler对象所关联的looper对象为handlerThread 中的looper，所以我们可以跟这个子线程进行通信。当执行start模式启动服务时候，执行onstartCommand 方法，内部把我们的的intent对象包装成msg，然后通过之前创建的handler 通信给子线程，所以可以执行耗时任务。


### BroadCastReceiver ###
#### 两种注册方式 ####
- 静态注册（在清单文件中注册） 只要app 在运行期间，该接受者就能够接收到广播
- 动态注册（在activity 或者service 代码中注册 ） 只能依附与所在的activity 或service 存在，当其载体不在时候则不能接收到广播。
#### 广播分类 ####
- 有序广播 ContextWrapper.sendOrderedBroadcast()
	传播具有一定顺序，根据接收者的优先级从高到低传播，如果中间某个接收者不往下传播，则后面的接收者不能接收到广播。
	（在有序广播中，可设置一个最终广播接收者，这个接收者在广播没有被中途中断的情况下可执行两次，一次是正常的传播，另一次是最终接收；而当广播中途中断时候该接收者也能final receiver）
- 无序广播 ContextWrapper.sendBroadCast()
	传播无序，如一些系统的一些锁屏开机等广播。这种广播传播效率高。
- 粘性广播 contextwrapper.sendStickyBroadCast() contextwrapper.sendStickyOrdereBroadCast()
	有无序和有序版本（）,(5.0后废弃)  发送的消息会被系统存储在容器中，解决广播事件发生太快来不及接收者来不急接收。
#### 生命周期 ####
	广播接收者的生命周期比较短，当onReciver （） 方法结束时候，接受者结束


### ContentProvider ###
	
#### 如何实现数据共享 ####
	内容提供者，使用时候继承contentprovider ，重写其增删改查等方法。（这点和sql 很像，但sql只能操作本应用的数据库，而内容提供者可以增删改查本地文件以及xml等）
	而其他第三方通过contentResolve 访问这提供者。
	
	ContentProvider 内容提供者，用于对外提供数据
	ContentResolver 内容解析者，用于获取内容提供者提供的数据
	ContentObserver 内容监听器，可以监听数据的改变状态
	ContentResolver.registerContentObserver()监听消息。

#### Android中数据存储的方式 ####
	文件，sp，网络，数据库

## Fragment ##
### 生命周期 ###
	onAttach()-->onCreate()-->onCreateView()-->onViewCreated-->onStart()-->onResume()-->onPause()-->onStop()-->onDetoryView()-->onDetroy()-->onDetach()
### FragmentManager ###
	管理Fragment ，有add ，show ，hide ，replace 等方法。
	而Fragment的事务管理器中，内部帮我们记录add和replace的Fragment，点击back时候自动帮我们处理退栈。
### Fragment与Activity，Fragment 之间的通信 ###
	1,fragment 通过 getActivity（）获取所依附的activity实例，再调用方法，getActivity（）..getFragmentManager().findFragmentById
	()可以获取其他fragment的实例再调用其方法。
	2，接口回调
	3，使用广播
	4，使用eventbus ，rxbus 这种事件总线

## WebView ##
	显示网页loadUrl（网址/本地文件）
	loadData();//加载html标签
### java 与js的交互 ###
	先得开启允许js脚本，setJavaScriptEnabled(true)
	1 js 调用 java
	window.类名.函数名字（参数）  java的函数名字必须加@javascripeInterface 注解
	2，调用js
	mWebView.loadUrl("javascript:函数名);
### WebSettings ###
	webviwe的设置类，可以设置属性和状态，如允许使用js，运行使用缓存等

WebSettings mWebSettings = webView.getSettings();
mWebSettings.setJavaScriptEnabled(true);// 支持JS
mWebSettings.setJavaScriptCanOpenWindowsAutomatically(true);//支持通过js打开新的窗口
mWebSettings.setRenderPriority(WebSettings.RenderPriority.HIGH);//提高渲染等级
mWebSettings.setBuiltInZoomControls(false);// 设置支持缩放
mWebSettings.setDomStorageEnabled(true);//使用localStorage则必须打开
mWebSettings.setBlockNetworkImage(true);// 首先阻塞图片，让图片不显示
mWebSettings.setBlockNetworkImage(false);//  页面加载好以后，在放开图片：
mWebSettings.setSupportMultipleWindows(false);// 设置同一个界面
mWebSettings.setBlockNetworkImage(false);
mWebSettings.setCacheMode(1);
mWebSettings.setNeedInitialFocus(false);// 禁止webview上面控件获取焦点(黄色边框)

### WebViewClient ###
	webviewClient 处理webview的各种通知，请求等事件。如：
	onpageStarted(),onPageFinished(),onReceivedError()....
### WebChromeClient ###
	webChromeClient 处理webview 中的js 事件，如对话框，网址图标，加载进度等等。。。。

----------

# Android 高级 #
## Handler消息机制 ##
	### 使用 ###
	handler 是android 里解决线程之间通信的。通常是在一个线程A内创建一个looper对象然后调用它的looper.loop（）方法。然后在另一个线程B创建一个handler 对象，让他跟之前创建的looper相关联（通过构造方法），然后B线程可以把所要发送的对象包装成msg对象再通过handler发送给线程
	A,然后在handler的handlerMessage方法内处理传递过来的msg对象；
	### 源码流程分析 ###
	其内部原理是：
		1，我们在调用looper.prepare()方法时候，它在所处的线程内创建了一个looer对象副本（使用Threadlocal包装，目的让线程拥有对象的独立副本），而在looper的构造内（私有）创建了一个messageQueue消息列队，和关联了当前Thread。
		2，当我们发送对象时候，把对象包装成message对象，然后调用handler的sendMessage方法，最终调用的是sendMessageAtTime()方法，而这个方法内主要是检查messageQueue不为空（创建handler时候需要关联一个looper对象然后可以获取到messageQueue对象），然后执行处理消息（enqueueMessage）方法,这个方法内主要是把msg的target属性赋值为该handler，然后让messageQueue处理消息。
		3，messageQueue处理消息。messageQueue里面含有一个message引用（message是单向列表数据结构，通过next属性连接，优点是增删快）。这里的主要逻辑是，把传递过来的msg，和time，根据msg中的when属性插入到当前的消息列队中。
		4，looper.loop()方法。里面先检测当前线程是否有looper对象副本，没有抛出异常。然后进行无限循环，不断从messageQueue中取出列队顶端的message（主要调用messagequeue.next()方法），然后调用message.target.dispathMessage()方法，里面调用了handlermessage()，也就是我们处理其他线程发送过来的message方法


## View的绘制 ##
### 源码分析（Activity的页面显示） ###
	1,
	我们通常都是给activity设置一个布局id，然后activity Resume时候可以看下view出现。观看其中源码，在activity 调用setcontentView后主要是调用windows.setContentView（）方法，而其中windows对象是phoneWindows,他在activity.attach()方法中被赋值。
	在phoneWindows的setContentView()方法里，主要逻辑是初始化DecorView(根据主题样式加载不同的布局)，然后把我们设置的contentView， 添加到decorview中。然后请求适应windows（调用decorview父容器（ViewrootImpl）requestFitSystemWindows（））方法。
	2,
	在Activity Resume过程中，ActivityThread 中通过handler 收到resume activity 的消息，然后执行handleResumeActivity（）方法，在这个方法中，主要把decorview添加到windows中。
	3,ViewrootImpl 中 requestFitSystemWindows
	主要执行先检查当前线程是否是主线程，然后执行遍历孩子，然后在Choreographer类post一个runable任务，这个任务主要是执行真正遍历performTraversals（），这里主要调用performMeasure，performLayout,performDraw方法，开始执行view的测量放置绘制

### onMeasure ###
	从viewrootimpl类的preformMeasure开始，里面调用view的Measure方法，里面主要的参数是measurespec
#### MeasureSpec 3种模式 ####
	把view的测量模式和测量封装成一个int值（4个字节32位），前2位是测量模式，后30位是测量值。
	AT_MOST：最大模式 相当于布局中设置wra_content
	EXACTLY：精确模式 相当于布局中设置MATCH_PARENT或设置xxdp
	UNSPECIFIED：无限制模式 孩子想要多大就多大
	
### onLayout ###
	如果该view是viewGroup ，遍历里面的子view,调用它的layout()方法。
	如果是view,主要是相对父容器设置左，上，右，下坐标。
### onDraw ###
	viewrootImp中的preformDraw方法内会根据view是否需要draw（根据view中一个标志位判断）才执行view的draw()方法
	内部流程，1，绘制该view的背景2，执行onDraw()方法。如果是viewGroup一般不重写onDraw(),会执行dispatchDraw()方法。
#### 画布相关操作 ####
	
1. 绘制操作
	主要有绘制点drawPoint，线drawLines，圆drawCircle，矩形drawRect，圆弧drawArc，椭圆drawOval
	以及绘制图片drawBitmap绘制文本drawText绘制路径drawPath
2. 变换操作
	位移，translate；旋转rotate，缩放scale，错切skew
3. 快照操作
	保存 save ，回滚上次 restore 画布。
#### 图形特效（色彩，形状） ####
#### 画笔特效 ####

## 动画特效 ##
### 属性动画 ###
ValueAnimator，ObjectAnimator把一个属性的数值从某个点到另外一个点，中间插值器可控制变化速度
### View动画 ###
### 5.0后转场以及元素共享动画 ###

## 事件分发 ##
### 事件拦截分发流程 ###

## 进程间通信 ##
### Android 进程的分类 ###
1. 使用Bundler
	用于4大组件进行数据传递
2. 文件共享
	无并发（可多读），数据实时性不高
3. Messenger
	
4. AIDL
5. ContentProvider
### AIDL ###
### Messenger ###
#### Binder机制 ####
#### Socket ####
#### 文件共享 ####

## 常见的View（主要是5.0后） ##
### RecyclerView ###
### Toolbar ###
### 协调者布局 ###

## 性能优化 ##
### 布局优化 ###
#### 避免过度绘制 ####
#### 优化布局层级 ####

### 内存优化 ###
#### java垃圾回收机制 ####
#### 4中引用 ####
#### 常见内存优化实例 ####


### 工具使用 ###
#### LeakCanary使用 ####
#### AS Memory Monitor ####
#### MAT ####
#### TraceView ####
#### Lint 代码检查####
----------

# 开源框架 #
## Retrofit ##
### 源码分析 ###
## RxJava ##
### 源码分析 ###
## ButterKnife ##
### 源码分析 ###
### aop编程 ###
## 图片加载框架 ##
### 自定义图片加载框架 ###
### LruCache ###
## 数据库框架 ##
### GreenDao ###
## 动态权限解决方案 ##
### 6.0 动态权限 ###
## 组件化，模块化，热修复(原理) ##
### DexClassLoader ###

----------

# 简历中项目 #
## 框架架构搭建 ##
### UI框架的搭建 ###
### 网络框架的搭建 ###

## IJK封装播放器 ##
### MediaPlay生命周期 ###
### 视频流编解码 ###

## 支付 ##
### 支付流程 ###
